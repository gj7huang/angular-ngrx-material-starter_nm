/**
 * @fileoverview added by tsickle
 * Generated from: lib/lazy-elements/lazy-elements-loader.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Optional, Inject } from '@angular/core';
import { LAZY_ELEMENT_ROOT_OPTIONS, LAZY_ELEMENTS_REGISTRY, } from './lazy-elements.tokens';
import * as i0 from "@angular/core";
import * as i1 from "./lazy-elements.tokens";
/** @type {?} */
const LOG_PREFIX = '@angular-extensions/elements';
/**
 * @record
 */
export function HooksConfig() { }
if (false) {
    /** @type {?|undefined} */
    HooksConfig.prototype.beforeLoad;
    /** @type {?|undefined} */
    HooksConfig.prototype.afterLoad;
}
/**
 * @record
 */
export function ElementConfig() { }
if (false) {
    /** @type {?} */
    ElementConfig.prototype.tag;
    /** @type {?} */
    ElementConfig.prototype.url;
    /** @type {?|undefined} */
    ElementConfig.prototype.isModule;
    /** @type {?|undefined} */
    ElementConfig.prototype.loadingComponent;
    /** @type {?|undefined} */
    ElementConfig.prototype.errorComponent;
    /** @type {?|undefined} */
    ElementConfig.prototype.preload;
    /** @type {?|undefined} */
    ElementConfig.prototype.hooks;
    /** @type {?|undefined} */
    ElementConfig.prototype.isAdded;
}
export class LazyElementsLoaderService {
    /**
     * @param {?} registry
     * @param {?} options
     */
    constructor(registry, options) {
        this.registry = registry;
        this.options = options;
        this.configs = [];
        if (!options) {
            this.options = {};
        }
    }
    /**
     * @param {?} newConfigs
     * @return {?}
     */
    addConfigs(newConfigs) {
        newConfigs.forEach((/**
         * @param {?} newConfig
         * @return {?}
         */
        (newConfig) => {
            /** @type {?} */
            const existingConfig = this.getElementConfig(newConfig.tag);
            if (existingConfig) {
                console.warn(`${LOG_PREFIX} - ElementConfig for tag '${newConfig.tag}' was previously added, it will not be added multiple times, continue...`);
            }
            else {
                newConfig.isAdded = true;
                this.configs.push(newConfig);
                /** @type {?} */
                const shouldPreload = newConfig.preload !== undefined
                    ? newConfig.preload
                    : this.options.preload;
                if (shouldPreload) {
                    this.loadElement(newConfig.url, newConfig.tag, newConfig.isModule, newConfig.hooks);
                }
            }
        }));
    }
    /**
     * @param {?} tag
     * @return {?}
     */
    getElementConfig(tag) {
        return this.configs.find((/**
         * @param {?} config
         * @return {?}
         */
        (config) => config.tag === tag));
    }
    /**
     * @param {?=} tags
     * @return {?}
     */
    preload(tags) {
        /** @type {?} */
        let configs = this.configs;
        if (tags) {
            configs = this.configs.filter((/**
             * @param {?} config
             * @return {?}
             */
            (config) => tags.includes(config.tag)));
        }
        configs.forEach((/**
         * @param {?} config
         * @return {?}
         */
        (config) => this.loadElement(config.url, config.tag, config.isModule, config.hooks)));
    }
    /**
     * @param {?} url
     * @param {?} tag
     * @param {?=} isModule
     * @param {?=} hooksConfig
     * @return {?}
     */
    loadElement(url, tag, isModule, hooksConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        /** @type {?} */
        const config = this.getElementConfig(tag);
        if (!url) {
            if (!config || !config.url) {
                throw new Error(`${LOG_PREFIX} - url for <${tag}> not found`);
            }
            url = config.url;
        }
        if (isModule === undefined) {
            isModule =
                config && config.isModule !== undefined
                    ? config.isModule
                    : this.options.isModule;
        }
        if (!tag) {
            throw new Error(`${LOG_PREFIX} - tag for '${url}' not found, the *axLazyElement has to be used on HTML element`);
        }
        if (!this.hasElement(url)) {
            /** @type {?} */
            const notifier = this.addElement(url);
            /** @type {?} */
            const script = (/** @type {?} */ (document.createElement('script')));
            /** @type {?} */
            const beforeLoadHook = (_c = (_a = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.beforeLoad) !== null && _a !== void 0 ? _a : (_b = config === null || config === void 0 ? void 0 : config.hooks) === null || _b === void 0 ? void 0 : _b.beforeLoad) !== null && _c !== void 0 ? _c : (_e = (_d = this.options) === null || _d === void 0 ? void 0 : _d.hooks) === null || _e === void 0 ? void 0 : _e.beforeLoad;
            /** @type {?} */
            const afterLoadHook = (_h = (_f = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.afterLoad) !== null && _f !== void 0 ? _f : (_g = config === null || config === void 0 ? void 0 : config.hooks) === null || _g === void 0 ? void 0 : _g.afterLoad) !== null && _h !== void 0 ? _h : (_k = (_j = this.options) === null || _j === void 0 ? void 0 : _j.hooks) === null || _k === void 0 ? void 0 : _k.afterLoad;
            if (isModule) {
                script.type = 'module';
            }
            script.src = url;
            script.onload = (/**
             * @return {?}
             */
            () => {
                if (afterLoadHook) {
                    this.handleHook(afterLoadHook, tag)
                        .then(notifier.resolve)
                        .catch(notifier.reject);
                }
                else {
                    notifier.resolve();
                }
            });
            script.onerror = notifier.reject;
            if (beforeLoadHook) {
                this.handleHook(beforeLoadHook, tag)
                    .then((/**
                 * @return {?}
                 */
                () => document.body.appendChild(script)))
                    .catch(notifier.reject);
            }
            else {
                document.body.appendChild(script);
            }
        }
        return this.registry.get(this.stripUrlProtocol(url));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    addElement(url) {
        /** @type {?} */
        let notifier;
        this.registry.set(this.stripUrlProtocol(url), new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => (notifier = { resolve, reject }))));
        return notifier;
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    hasElement(url) {
        return this.registry.has(this.stripUrlProtocol(url));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    stripUrlProtocol(url) {
        return url.replace(/https?:\/\//, '');
    }
    /**
     * @private
     * @template T
     * @param {?} obj
     * @return {?}
     */
    isPromise(obj) {
        var _a;
        return typeof ((_a = ((/** @type {?} */ (obj)))) === null || _a === void 0 ? void 0 : _a.then) === 'function';
    }
    /**
     * @private
     * @param {?} hook
     * @param {?} tag
     * @return {?}
     */
    handleHook(hook, tag) {
        try {
            /** @type {?} */
            const result = hook(tag);
            if (this.isPromise(result)) {
                return result;
            }
            else {
                return Promise.resolve();
            }
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
}
LazyElementsLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
LazyElementsLoaderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_ELEMENTS_REGISTRY,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LAZY_ELEMENT_ROOT_OPTIONS,] }] }
];
/** @nocollapse */ LazyElementsLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyElementsLoaderService_Factory() { return new LazyElementsLoaderService(i0.ɵɵinject(i1.LAZY_ELEMENTS_REGISTRY), i0.ɵɵinject(i1.LAZY_ELEMENT_ROOT_OPTIONS, 8)); }, token: LazyElementsLoaderService, providedIn: "root" });
if (false) {
    /** @type {?} */
    LazyElementsLoaderService.prototype.configs;
    /**
     * @type {?}
     * @private
     */
    LazyElementsLoaderService.prototype.registry;
    /** @type {?} */
    LazyElementsLoaderService.prototype.options;
}
/**
 * @record
 */
function Notifier() { }
if (false) {
    /** @type {?} */
    Notifier.prototype.resolve;
    /** @type {?} */
    Notifier.prototype.reject;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1lbGVtZW50cy1sb2FkZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2VsZW1lbnRzL3NyYy9saWIvbGF6eS1lbGVtZW50cy9sYXp5LWVsZW1lbnRzLWxvYWRlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBUSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBR25FLE9BQU8sRUFDTCx5QkFBeUIsRUFDekIsc0JBQXNCLEdBRXZCLE1BQU0sd0JBQXdCLENBQUM7Ozs7TUFFMUIsVUFBVSxHQUFHLDhCQUE4Qjs7OztBQUlqRCxpQ0FHQzs7O0lBRkMsaUNBQWtCOztJQUNsQixnQ0FBaUI7Ozs7O0FBR25CLG1DQVNDOzs7SUFSQyw0QkFBWTs7SUFDWiw0QkFBWTs7SUFDWixpQ0FBbUI7O0lBQ25CLHlDQUE2Qjs7SUFDN0IsdUNBQTJCOztJQUMzQixnQ0FBa0I7O0lBQ2xCLDhCQUFvQjs7SUFDcEIsZ0NBQWtCOztBQU1wQixNQUFNLE9BQU8seUJBQXlCOzs7OztJQUdwQyxZQUMwQyxRQUE4QixFQUcvRCxPQUErQjtRQUhFLGFBQVEsR0FBUixRQUFRLENBQXNCO1FBRy9ELFlBQU8sR0FBUCxPQUFPLENBQXdCO1FBTnhDLFlBQU8sR0FBb0IsRUFBRSxDQUFDO1FBUTVCLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztTQUNuQjtJQUNILENBQUM7Ozs7O0lBRUQsVUFBVSxDQUFDLFVBQTJCO1FBQ3BDLFVBQVUsQ0FBQyxPQUFPOzs7O1FBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRTs7a0JBQ3pCLGNBQWMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztZQUMzRCxJQUFJLGNBQWMsRUFBRTtnQkFDbEIsT0FBTyxDQUFDLElB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QUMsQ0FBQztTQUM1QjtJQUNILENBQUM7OztZQTFKRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs7NENBS0ksTUFBTSxTQUFDLHNCQUFzQjs0Q0FDN0IsUUFBUSxZQUNSLE1BQU0sU0FBQyx5QkFBeUI7Ozs7O0lBTG5DLDRDQUE4Qjs7Ozs7SUFHNUIsNkNBQXNFOztJQUN0RSw0Q0FFc0M7Ozs7O0FBbUoxQyx1QkFHQzs7O0lBRkMsMkJBQW9COztJQUNwQiwwQkFBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBUeXBlLCBPcHRpb25hbCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IExhenlFbGVtZW50Um9vdE9wdGlvbnMgfSBmcm9tICcuL2xhenktZWxlbWVudHMubW9kdWxlJztcbmltcG9ydCB7XG4gIExBWllfRUxFTUVOVF9ST09UX09QVElPTlMsXG4gIExBWllfRUxFTUVOVFNfUkVHSVNUUlksXG4gIExhenlFbGVtZW50c1JlZ2lzdHJ5LFxufSBmcm9tICcuL2xhenktZWxlbWVudHMudG9rZW5zJztcblxuY29uc3QgTE9HX1BSRUZJWCA9ICdAYW5ndWxhci1leHRlbnNpb25zL2VsZW1lbnRzJztcblxuZXhwb3J0IHR5cGUgSG9vayA9ICh0YWc6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSG9va3NDb25maWcge1xuICBiZWZvcmVMb2FkPzogSG9vaztcbiAgYWZ0ZXJMb2FkPzogSG9vaztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50Q29uZmlnIHtcbiAgdGFnOiBzdHJpbmc7XG4gIHVybDogc3RyaW5nO1xuICBpc01vZHVsZT86IGJvb2xlYW47XG4gIGxvYWRpbmdDb21wb25lbnQ/OiBUeXBlPGFueT47XG4gIGVycm9yQ29tcG9uZW50PzogVHlwZTxhbnk+O1xuICBwcmVsb2FkPzogYm9vbGVhbjtcbiAgaG9va3M/OiBIb29rc0NvbmZpZztcbiAgaXNBZGRlZD86IGJvb2xlYW47XG59XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBMYXp5RWxlbWVudHNMb2FkZXJTZXJ2aWNlIHtcbiAgY29uZmlnczogRWxlbWVudENvbmZpZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChMQVpZX0VMRU1FTlRTX1JFR0lTVFJZKSBwcml2YXRlIHJlZ2lzdHJ5OiBMYXp5RWxlbWVudHNSZWdpc3RyeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoTEFaWV9FTEVNRU5UX1JPT1RfT1BUSU9OUylcbiAgICBwdWJsaWMgb3B0aW9uczogTGF6eUVsZW1lbnRSb290T3B0aW9uc1xuICApIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIGFkZENvbmZpZ3MobmV3Q29uZmlnczogRWxlbWVudENvbmZpZ1tdKSB7XG4gICAgbmV3Q29uZmlncy5mb3JFYWNoKChuZXdDb25maWcpID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ29uZmlnID0gdGhpcy5nZXRFbGVtZW50Q29uZmlnKG5ld0NvbmZpZy50YWcpO1xuICAgICAgaWYgKGV4aXN0aW5nQ29uZmlnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgJHtMT0dfUFJFRklYfSAtIEVsZW1lbnRDb25maWcgZm9yIHRhZyAnJHtuZXdDb25maWcudGFnfScgd2FzIHByZXZpb3VzbHkgYWRkZWQsIGl0IHdpbGwgbm90IGJlIGFkZGVkIG11bHRpcGxlIHRpbWVzLCBjb250aW51ZS4uLmBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NvbmZpZy5pc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jb25maWdzLnB1c2gobmV3Q29uZmlnKTtcbiAgICAgICAgY29uc3Qgc2hvdWxkUHJlbG9hZCA9XG4gICAgICAgICAgbmV3Q29uZmlnLnByZWxvYWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXdDb25maWcucHJlbG9hZFxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMucHJlbG9hZDtcbiAgICAgICAgaWYgKHNob3VsZFByZWxvYWQpIHtcbiAgICAgICAgICB0aGlzLmxvYWRFbGVtZW50KFxuICAgICAgICAgICAgbmV3Q29uZmlnLnVybCxcbiAgICAgICAgICAgIG5ld0NvbmZpZy50YWcsXG4gICAgICAgICAgICBuZXdDb25maWcuaXNNb2R1bGUsXG4gICAgICAgICAgICBuZXdDb25maWcuaG9va3NcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRFbGVtZW50Q29uZmlnKHRhZzogc3RyaW5nKTogRWxlbWVudENvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlncy5maW5kKChjb25maWcpID0+IGNvbmZpZy50YWcgPT09IHRhZyk7XG4gIH1cblxuICBwcmVsb2FkKHRhZ3M/OiBzdHJpbmdbXSkge1xuICAgIGxldCBjb25maWdzID0gdGhpcy5jb25maWdzO1xuICAgIGlmICh0YWdzKSB7XG4gICAgICBjb25maWdzID0gdGhpcy5jb25maWdzLmZpbHRlcigoY29uZmlnKSA9PiB0YWdzLmluY2x1ZGVzKGNvbmZpZy50YWcpKTtcbiAgICB9XG4gICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+XG4gICAgICB0aGlzLmxvYWRFbGVtZW50KGNvbmZpZy51cmwsIGNvbmZpZy50YWcsIGNvbmZpZy5pc01vZHVsZSwgY29uZmlnLmhvb2tzKVxuICAgICk7XG4gIH1cblxuICBsb2FkRWxlbWVudChcbiAgICB1cmw6IHN0cmluZyxcbiAgICB0YWc6IHN0cmluZyxcbiAgICBpc01vZHVsZT86IGJvb2xlYW4sXG4gICAgaG9va3NDb25maWc/OiBIb29rc0NvbmZpZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldEVsZW1lbnRDb25maWcodGFnKTtcblxuICAgIGlmICghdXJsKSB7XG4gICAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLnVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7TE9HX1BSRUZJWH0gLSB1cmwgZm9yIDwke3RhZ30+IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgdXJsID0gY29uZmlnLnVybDtcbiAgICB9XG5cbiAgICBpZiAoaXNNb2R1bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXNNb2R1bGUgPVxuICAgICAgICBjb25maWcgJiYgY29uZmlnLmlzTW9kdWxlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IGNvbmZpZy5pc01vZHVsZVxuICAgICAgICAgIDogdGhpcy5vcHRpb25zLmlzTW9kdWxlO1xuICAgIH1cblxuICAgIGlmICghdGFnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGAke0xPR19QUkVGSVh9IC0gdGFnIGZvciAnJHt1cmx9JyBub3QgZm91bmQsIHRoZSAqYXhMYXp5RWxlbWVudCBoYXMgdG8gYmUgdXNlZCBvbiBIVE1MIGVsZW1lbnRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXNFbGVtZW50KHVybCkpIHtcbiAgICAgIGNvbnN0IG5vdGlmaWVyID0gdGhpcy5hZGRFbGVtZW50KHVybCk7XG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSBhcyBIVE1MU2NyaXB0RWxlbWVudDtcbiAgICAgIGNvbnN0IGJlZm9yZUxvYWRIb29rID1cbiAgICAgICAgaG9va3NDb25maWc/LmJlZm9yZUxvYWQgPz9cbiAgICAgICAgY29uZmlnPy5ob29rcz8uYmVmb3JlTG9hZCA/P1xuICAgICAgICB0aGlzLm9wdGlvbnM/Lmhvb2tzPy5iZWZvcmVMb2FkO1xuICAgICAgY29uc3QgYWZ0ZXJMb2FkSG9vayA9XG4gICAgICAgIGhvb2tzQ29uZmlnPy5hZnRlckxvYWQgPz9cbiAgICAgICAgY29uZmlnPy5ob29rcz8uYWZ0ZXJMb2FkID8/XG4gICAgICAgIHRoaXMub3B0aW9ucz8uaG9va3M/LmFmdGVyTG9hZDtcbiAgICAgIGlmIChpc01vZHVsZSkge1xuICAgICAgICBzY3JpcHQudHlwZSA9ICdtb2R1bGUnO1xuICAgICAgfVxuICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChhZnRlckxvYWRIb29rKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVIb29rKGFmdGVyTG9hZEhvb2ssIHRhZylcbiAgICAgICAgICAgIC50aGVuKG5vdGlmaWVyLnJlc29sdmUpXG4gICAgICAgICAgICAuY2F0Y2gobm90aWZpZXIucmVqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3RpZmllci5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzY3JpcHQub25lcnJvciA9IG5vdGlmaWVyLnJlamVjdDtcbiAgICAgIGlmIChiZWZvcmVMb2FkSG9vaykge1xuICAgICAgICB0aGlzLmhhbmRsZUhvb2soYmVmb3JlTG9hZEhvb2ssIHRhZylcbiAgICAgICAgICAudGhlbigoKSA9PiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCkpXG4gICAgICAgICAgLmNhdGNoKG5vdGlmaWVyLnJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuZ2V0KHRoaXMuc3RyaXBVcmxQcm90b2NvbCh1cmwpKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkRWxlbWVudCh1cmw6IHN0cmluZyk6IE5vdGlmaWVyIHtcbiAgICBsZXQgbm90aWZpZXI6IE5vdGlmaWVyO1xuICAgIHRoaXMucmVnaXN0cnkuc2V0KFxuICAgICAgdGhpcy5zdHJpcFVybFByb3RvY29sKHVybCksXG4gICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiAobm90aWZpZXIgPSB7IHJlc29sdmUsIHJlamVjdCB9KSlcbiAgICApO1xuICAgIHJldHVybiBub3RpZmllcjtcbiAgfVxuXG4gIHByaXZhdGUgaGFzRWxlbWVudCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5Lmhhcyh0aGlzLnN0cmlwVXJsUHJvdG9jb2wodXJsKSk7XG4gIH1cblxuICBwcml2YXRlIHN0cmlwVXJsUHJvdG9jb2wodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvaHR0cHM/OlxcL1xcLy8sICcnKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNQcm9taXNlPFQ+KG9iajogVCB8IFByb21pc2U8VD4pOiBvYmogaXMgUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHR5cGVvZiAob2JqIGFzIGFueSk/LnRoZW4gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUhvb2soaG9vazogSG9vaywgdGFnOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaG9vayh0YWcpO1xuICAgICAgaWYgKHRoaXMuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfVxufVxuXG5pbnRlcmZhY2UgTm90aWZpZXIge1xuICByZXNvbHZlOiAoKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogYW55KSA9PiB2b2lkO1xufVxuIl19